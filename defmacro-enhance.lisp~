;;;; defmacro-enhance.lisp
;;;;
;;;; This file is part of the defmacro-enhance library, released under GPL.
;;;; See file COPYING for details.
;;;;
;;;; Author: Alexander Popolitov

(in-package #:defmacro-enhance)

(defmacro def-*!-symbol-p (symb)
  "Define test-function for argument to be prefix-bang-hyphen symbol."
  (let ((s-symb (string symb)))
    `(defun ,(intern (format nil "~a~a"(string s-symb) "!-SYMBOL-P")) (symb)
       (and (symbolp symb)
	    (> (length (string symb)) ,(+ (length s-symb) 2))
	    (equal (subseq (string symb) 0 ,(+ (length s-symb) 2))
		   ,(format nil "~a~a" (string s-symb) "!-"))))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (def-*!-symbol-p g)
  (def-*!-symbol-p o)
  (def-*!-symbol-p e))

;; My own version of parse-body, just to not depend on anyone
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun parse-body (body)
    (let (doc-string)
      (if (and (> (length body) 1)
	       (stringp (car body)))
	  (setf doc-string (car body)
		body (cdr body)))
      (iter (with non-decl-met = nil)
	    (for form in body)
	    (if (not non-decl-met)
		(if (equal (car form) 'declare)
		    (collect form into declarations)
		    (progn (setf non-decl-met t)
			   (collect form into forms)))
		(collect form into forms))
	    (finally (return (values forms declarations doc-string)))))))
      

(defmacro define-/g! (src-name dst-name args &body body)
  "Define macro SRC-NAME on top of DST-NAME. Arg list of DST-NAME should
contain BODY. All g!-symbols in BODY are transformed to gensyms."
  (let ((g!-forms (gensym "FORMS"))
	(g!-decls (gensym "DECLS"))
	(g!-doc (gensym "DOC"))
	(g!-syms (gensym "SYMS")))
  `(defmacro ,src-name ,args
     (multiple-value-bind (,g!-forms ,g!-decls ,g!-doc) (parse-body body)
       (let ((,g!-syms (remove-duplicates
			(remove-if-not #'g!-symbol-p
				       (alexandria:flatten ,g!-forms)))))
	 (let ((,(intern "BODY")
		`(,@(if ,g!-doc `(,,g!-doc))
		    ,@,g!-decls
		    ,@(if ,g!-syms
			  `((let ,(mapcar (lambda (s)
					    `(,s (gensym ,(subseq (symbol-name s) 3))))
					  ,g!-syms)
			      ,@,g!-forms))
			  ,g!-forms))))
	   (append `(,',dst-name)
		   (progn ,@body))))))))

(define-/g! defmacro/g! defmacro (name args &body body)
  `(,name ,args ,@body))

(define-/g! defmacro-driver/g! defmacro-driver (clause-template &body body)
  `(,clause-template ,@body))

(define-/g! defun/g! defun (name args &body body)
  `(,name ,args ,@body))

;; ONCE-ONLY just not to depend on RUTILS, which I plan to enhance
;; Limited version, to use once only for my needs.
(defmacro once-only ((&rest specs) &body body)
  (let ((gensyms (mapcar (lambda (sym) (gensym (string sym))) specs)))
    `(let ,(mapcar (lambda (g s)
		     `(,g (gensym ,(string s))))
		   gensyms specs)
       `(let (,,@(mapcar (lambda (g s)
			   ``(,,g ,,s))
			 gensyms specs))
	  ,(let ,(mapcar (lambda (s g)
			   `(,s ,g))
			 specs gensyms)
		,@body)))))

(defmacro/g! define-/o! (src-name dst-name args &body body)
  "All o!-symbols in the ARGS variable of the DST-NAME macro are
treated as once-only symbols. BODY variable is parsed accordingly."
  `(defmacro ,src-name ,args
     (multiple-value-bind (,g!-forms ,g!-decls ,g!-doc) (parse-body body)
       (let ((,g!-syms (remove-duplicates
			(remove-if-not #'o!-symbol-p (alexandria:flatten args)))))
	 (let ((,(intern "BODY")
		`(,@(if ,g!-doc `(,,g!-doc))
		    ,@,g!-decls
		    (once-only ,,g!-syms
		      ,@,g!-forms))))
	   (append `(,',dst-name)
		   (progn ,@body)))))))

(define-/o! defmacro/g!/o! defmacro/g! (name args &body body)
  `(,name ,args ,@body))

(defmacro/g! define-/e! (src-name dst-name args &body body)
  "Deformation, in which E!-symbols are interned in package,
where macro is expanded, not where it is defined.
Useful for writing anaphoric macros."
  `(defmacro ,src-name ,args
     (multiple-value-bind (,g!-forms ,g!-decls ,g!-doc) (parse-body body)
       (let ((,g!-syms (remove-duplicates
			(remove-if-not #'e!-symbol-p (alexandria:flatten ,g!-forms)))))
	 (let ((,(intern "BODY")
		`(,@(if ,g!-doc `(,,g!-doc))
		    ,@,g!-decls
		    (let ,(mapcar (lambda (sym)
				    `(,sym (intern ,(subseq (string sym) 3))))
				  ,g!-syms)
		      ,@,g!-forms))))
	   (append `(,',dst-name)
		   (progn ,@body)))))))

(define-/e! defmacro/g!/o!/e! defmacro/g!/o! (name args &body body)
  `(,name ,args ,@body))

(define-/e! defmacro-driver/g!/e! defmacro-driver/g! (clause-template &body body)
  `(,clause-template ,@body))

(define-/e! defun/g!/e! defun/g! (name args &body body)
  `(,name ,args ,@body))


;; If some new defmacro/'s will be added, then change the following alias macroexpansion
(defmacro defmacro! (name args &body body)
  "Like defmacro, but with some extra perks."
  `(defmacro/g!/o!/e! ,name ,args ,@body))

(defmacro defmacro-driver! (clause-template &body body)
  "Like defmacro, but with some extra perks."
  `(defmacro-driver/g!/e! ,clause-template ,@body))

(defmacro defun! (name args &body body)
  `(defun/g!/e! ,name ,args ,@body))
